# 디자인 패턴 (Dart)

## GoF, 세 가지 디자인 패턴 분류

| 분류                                                                | 특징                                                                   | 예시                                                        |
| ------------------------------------------------------------------- | ---------------------------------------------------------------------- | ----------------------------------------------------------- |
| [생성(Creational) 디자인 패턴](#종류-1-생성-creational-디자인-패턴) | 하나 또는 여러 개의 객체를 어떻게 초기화할지를 중점으로 둠             | Factory, Builder, Prototype, Singleton, ...                 |
| [구조(Structural) 디자인 패턴](#종류-2-구조-structural-디자인-패턴) | 상속보다 객체 간의 "구성"에 집중                                       | Decorator, Adapter, Composite, Facade, Proxy, ...           |
| [행위(Behavioral) 디자인 패턴](#종류-3-행위-behavioral-디자인-패턴) | 각 객체에 기능을 분배하고, 서로 간의 연결과 커뮤니케이션을 중점으로 둠 | Strategy, Observer, State, Command, Iterator, Template, ... |

---

## 여섯 가지 설계 원칙

### SOLID 원칙

- **단일 책임 원칙 (Single Responsibility Principle, SRP)**
  클래스나 함수 등 모든 객체는 단 하나의 책임에만 집중해야 한다.
  여러 책임을 한 객체에 두면 가독성도 떨어지고, 오류 발생 시 문제 추적도 어렵다.
  여러 책임이 얽히면 재사용성도 낮아진다.

- **개방/폐쇄 원칙 (Open/Closed Principle, OCP)**

  > 시스템의 기능 확장은 **새로운 코드를 추가하는 방식**으로 하며,
  > 기존의 동작 중인 코드를 **수정하지 않고** 확장할 수 있어야 한다.
  > 기존 코드에는 손대지 않고, 새 기능은 다른 방식으로 추가한다.
  > 기존 코드를 수정하면 예기치 않은 오류가 발생할 수 있다.
  > _※ 확장성과 유지보수성을 높이기 위해 인터페이스나 추상 클래스 사용을 권장한다._

- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**

  > 기반 클래스(부모 클래스)가 사용되는 모든 곳에서 자식 클래스로 치환 가능해야 한다.
  > 자식 클래스는 부모의 기능을 확장할 수 있지만, 원래의 기능을 변경해서는 안 된다.
  > 소프트웨어가 예측대로 동작하려면 상속 구조에서 이 원칙이 필수다.
  > _※ OCP를 실현하기 위한 핵심인 추상화의 구체적 기준이 되는 원칙이다._

- **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**

  > 큰 인터페이스 하나보다는, 작고 구체적인 인터페이스 여러 개를 사용하는 게 좋다.
  > 유지보수와 확장을 쉽게 하려면 클래스 간 의존성과 결합도를 낮추어야 한다.

- **의존 역전 원칙 (Dependency Inversion Principle, DIP)**

  > 구체 클래스가 아니라 **추상에 의존**해야 한다.
  > 상위/하위 계층 모두가 추상 클래스나 인터페이스에 의존하며,
  > 구현체는 이 추상에 따라 동작해야 한다.

- **최소 지식 원칙 (Least Knowledge Principle, LKP)**

  > "바로 옆 친구랑만 대화해라."
  > 객체는 너무 많은 다른 객체와 상호작용하지 않아야 한다.
  > 한 객체의 변경이 다른 객체에 미치는 영향을 최소화하여, 확장을 쉽게 한다.
  > (핵심은 디커플링)

---

## 추가 설계 원칙

- **DRY 원칙 (Do Not Repeat Yourself)**

  > 같은 기능은 시스템 안에 단 한 번만 구현되어야 한다.
  > 반복되는 코드(주석, 숨겨진 중복 포함)는 추상화하여 중복을 제거해야 한다.
  > 중복은 유지보수를 어렵게 하고 확장을 막는다.

- **KISS 원칙 (Keep It Simple and Stupid)**

  > 단순함이 최선이다.
  > 복잡한 로직보다 명확한 단순함이 안정성과 유지보수성에 유리하다.

- **YAGNI 원칙 (You Ain't Gonna Need It)**

  > "당신은 그 기능을 결국 안 쓸 거예요."
  > 실제 사용하지 않을 기능은 만들지 말라는 뜻이다.
  > 필요한 최소한의 것부터 빠르게 만들고, 나중에 확장하라.
  > _※ “디자인을 위한 디자인은 피하라”는 철학도 담고 있음._

- **ROT 원칙 (Rule of Three)**

  > 같은 기능이 **세 번째**로 등장했을 때만 추상화하라.

  - 추상화는 비용이 크기 때문에, 두 번까진 반복을 허용한다.
  - 세 번째부터는 패턴이 명확해지므로 추상화 타이밍으로 적절하다.

- **CRP 원칙 (Composite Reuse Principle)**

  > 상속보다 조합(구성, Aggregation/Composition)을 선호하라.

  - 기존 객체를 **합성**해서 새로운 객체를 만들고,
  - 이 새 객체가 기존 객체의 기능을 **위임**하는 구조가 유지보수에 유리하다.

---

## 종류 1: 생성(Creational) 디자인 패턴

### 🍕 Simple Factory

**목적**:
Client가 어떤 객체를 생성할지 알 필요 없이, 생성 방법만 제공

**언제 사용하나**:
객체를 만들 때 로직이 복잡할 경우, 코드 중복 없이 관리하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍔 Factory Method

**목적**:
객체 생성을 서브클래스에 맡기고, 인터페이스만 제공

**언제 사용하나**:
공통 속성이 있는 하위 클래스들을 런타임에 동적으로 결정해야 할 때

💎 [예시 코드](src/Creational/FactoryMethod.dart)

---

### 🍟 Abstract Factory

**목적**:
관련된 객체 집합을 만들기 위한 인터페이스 제공, 클래스 노출 없음

**언제 사용하나**:
의존관계가 있는 객체들을 함께 만들어야 하며, 로직이 복잡한 경우

💎 [예시 코드](src/Creational/AbstractFactory.dart)

---

### 🌭 Builder

**목적**:
복잡한 객체를 작은 구성 요소로 나눠 순차적으로 조립 (예: 게임 캐릭터)

**언제 사용하나**:
옵션이 많은 객체를 생성할 때, 생성자에 모든 속성을 넣고 싶지 않을 때

💎 [예시 코드](src/Creational/Builder.dart)

---

### 🍿 Prototype

**목적**:
기존 객체를 복제해서 새로운 객체를 생성

**언제 사용하나**:
기존 객체와 거의 같은 구조의 객체가 필요할 때

💎 [예시 코드](src/Creational/Prototype.dart)

---

### 🥞 Singleton

**목적**:
객체를 하나만 만들고, 전역으로 접근 가능하게 보장

**언제 사용하나**:
인스턴스를 절대 중복 생성하지 않게 제한하고 싶을 때

💎 [예시 코드](src/Creational/Singleton.dart)
