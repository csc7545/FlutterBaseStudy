# 디자인 패턴 (Dart)

## GoF, 세 가지 디자인 패턴 분류

| 분류                                                        | 특징                                                                   | 예시                                                        |
| ----------------------------------------------------------- | ---------------------------------------------------------------------- | ----------------------------------------------------------- |
| [생성(Creational) 디자인 패턴](#생성Creational-디자인-패턴) | 하나 또는 여러 개의 객체를 어떻게 초기화할지를 중점으로 둠             | Factory, Builder, Prototype, Singleton, ...                 |
| [구조(Structural) 디자인 패턴](#구조Structural-디자인-패턴) | 상속보다 객체 간의 "구성"에 집중                                       | Decorator, Adapter, Composite, Facade, Proxy, ...           |
| [행위(Behavioral) 디자인 패턴](#행위Behavioral-디자인-패턴) | 각 객체에 기능을 분배하고, 서로 간의 연결과 커뮤니케이션을 중점으로 둠 | Strategy, Observer, State, Command, Iterator, Template, ... |

---

## 여섯 가지 설계 원칙

### SOLID 원칙

- **단일 책임 원칙 (Single Responsibility Principle, SRP)**

  > 클래스나 함수 등 모든 객체는 단 하나의 책임에만 집중해야 한다.
  > 여러 책임을 한 객체에 두면 가독성도 떨어지고, 오류 발생 시 문제 추적도 어렵다.
  > 여러 책임이 얽히면 재사용성도 낮아진다.

- **개방/폐쇄 원칙 (Open/Closed Principle, OCP)**

  > 시스템의 기능 확장은 **새로운 코드를 추가하는 방식**으로 하며,
  > 기존의 동작 중인 코드를 **수정하지 않고** 확장할 수 있어야 한다.
  > 기존 코드에는 손대지 않고, 새 기능은 다른 방식으로 추가한다.
  > 기존 코드를 수정하면 예기치 않은 오류가 발생할 수 있다.
  > _※ 확장성과 유지보수성을 높이기 위해 인터페이스나 추상 클래스 사용을 권장한다._

- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**

  > 기반 클래스(부모 클래스)가 사용되는 모든 곳에서 자식 클래스로 치환 가능해야 한다.
  > 자식 클래스는 부모의 기능을 확장할 수 있지만, 원래의 기능을 변경해서는 안 된다.
  > 소프트웨어가 예측대로 동작하려면 상속 구조에서 이 원칙이 필수다.
  > _※ OCP를 실현하기 위한 핵심인 추상화의 구체적 기준이 되는 원칙이다._

- **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**

  > 큰 인터페이스 하나보다는, 작고 구체적인 인터페이스 여러 개를 사용하는 게 좋다.
  > 유지보수와 확장을 쉽게 하려면 클래스 간 의존성과 결합도를 낮추어야 한다.

- **의존 역전 원칙 (Dependency Inversion Principle, DIP)**

  > 구체 클래스가 아니라 **추상에 의존**해야 한다.
  > 상위/하위 계층 모두가 추상 클래스나 인터페이스에 의존하며,
  > 구현체는 이 추상에 따라 동작해야 한다.

- **최소 지식 원칙 (Least Knowledge Principle, LKP)**

  > "바로 옆 친구랑만 대화해라."
  > 객체는 너무 많은 다른 객체와 상호작용하지 않아야 한다.
  > 한 객체의 변경이 다른 객체에 미치는 영향을 최소화하여, 확장을 쉽게 한다.
  > (핵심은 디커플링)

---

## 추가 설계 원칙

- **DRY 원칙 (Do Not Repeat Yourself)**

  > 같은 기능은 시스템 안에 단 한 번만 구현되어야 한다.
  > 반복되는 코드(주석, 숨겨진 중복 포함)는 추상화하여 중복을 제거해야 한다.
  > 중복은 유지보수를 어렵게 하고 확장을 막는다.

- **KISS 원칙 (Keep It Simple and Stupid)**

  > 단순함이 최선이다.
  > 복잡한 로직보다 명확한 단순함이 안정성과 유지보수성에 유리하다.

- **YAGNI 원칙 (You Ain't Gonna Need It)**

  > "당신은 그 기능을 결국 안 쓸 거예요."
  > 실제 사용하지 않을 기능은 만들지 말라는 뜻이다.
  > 필요한 최소한의 것부터 빠르게 만들고, 나중에 확장하라.
  > _※ “디자인을 위한 디자인은 피하라”는 철학도 담고 있음._

- **ROT 원칙 (Rule of Three)**

  > 같은 기능이 **세 번째**로 등장했을 때만 추상화하라.

  - 추상화는 비용이 크기 때문에, 두 번까진 반복을 허용한다.
  - 세 번째부터는 패턴이 명확해지므로 추상화 타이밍으로 적절하다.

- **CRP 원칙 (Composite Reuse Principle)**

  > 상속보다 조합(구성, Aggregation/Composition)을 선호하라.

  - 기존 객체를 **합성**해서 새로운 객체를 만들고,
  - 이 새 객체가 기존 객체의 기능을 **위임**하는 구조가 유지보수에 유리하다.

---

## 생성(Creational) 디자인 패턴

### 🍕 Simple Factory

**목적**:
Client가 어떤 객체를 생성할지 알 필요 없이, 생성 방법만 제공

**언제 사용하나**:
객체를 만들 때 로직이 복잡할 경우, 코드 중복 없이 관리하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍔 Factory Method

**목적**:
객체 생성을 서브클래스에 맡기고, 인터페이스만 제공

**언제 사용하나**:
공통 속성이 있는 하위 클래스들을 런타임에 동적으로 결정해야 할 때

💎 [예시 코드](src/Creational/FactoryMethod.dart)

---

### 🍟 Abstract Factory

**목적**:
관련된 객체 집합을 만들기 위한 인터페이스 제공, 클래스 노출 없음

**언제 사용하나**:
의존관계가 있는 객체들을 함께 만들어야 하며, 로직이 복잡한 경우

💎 [예시 코드](lib/patterns/creational/abstract_factory.dart)

---

### 🌭 Builder

**목적**:
복잡한 객체를 작은 구성 요소로 나눠 순차적으로 조립 (예: 게임 캐릭터)

**언제 사용하나**:
옵션이 많은 객체를 생성할 때, 생성자에 모든 속성을 넣고 싶지 않을 때

💎 [예시 코드](src/Creational/Builder.dart)

---

### 🍿 Prototype

**목적**:
기존 객체를 복제해서 새로운 객체를 생성

**언제 사용하나**:
기존 객체와 거의 같은 구조의 객체가 필요할 때

💎 [예시 코드](src/Creational/Prototype.dart)

---

### 🥞 Singleton

**목적**:
객체를 하나만 만들고, 전역으로 접근 가능하게 보장

**언제 사용하나**:
인스턴스를 절대 중복 생성하지 않게 제한하고 싶을 때

💎 [예시 코드](src/Creational/Singleton.dart)

---

## 구조(Structural) 디자인 패턴

### 🍙 Adapter

**목적**
: 하나의 인터페이스를 다른 인터페이스로 변환하여, 원래는 함께 동작할 수 없었던 클래스들이 함께 동작할 수 있게 한다.

**언제 사용하나**
: 기존 클래스를 사용하고 싶지만, 해당 클래스의 인터페이스가 요구사항에 맞지 않을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍣 Bridge

**목적**
: 상속 대신 조합(구성)을 사용하여 과도한 상속을 피한다.

**언제 사용하나**
: 웹사이트에 여러 페이지가 있고, 각기 다른 테마가 있는 경우. 페이지마다 테마를 상속할지, 페이지와 테마를 분리해 조합할지 고민될 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍖 Composite

**목적**
: 동일한 인터페이스지만 서로 다른 기능을 가진 객체들을 트리 구조로 구성하여 관리한다.

**언제 사용하나**
: 유사한 객체들을 한데 모아 트리 구조로 통합하여 관리하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍤 Decorator

**목적**
: 기존 객체에 기능을 동적으로 추가할 수 있으며, 상속보다 유연한 확장을 제공한다.

**언제 사용하나**
: 동적으로 추가할 기능이 많고, 상속으로 해결하려 하면 구조가 복잡해질 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🥙 Facade

**목적**
: 여러 개의 하위 시스템을 쉽게 사용할 수 있도록 고수준 인터페이스를 제공한다.

**언제 사용하나**
: 복잡한 여러 하위 시스템을 일일이 호출하기 어려울 때, 단순한 API로 묶고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🥗 Flyweight

**목적**
: 동일하거나 유사한 객체를 공유하여 메모리 사용을 최소화한다.

**언제 사용하나**
: 객체의 수가 많거나, 많은 메모리를 요구하는 상황에서 효율적으로 관리할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🥣 Proxy

**목적**
: 클래스의 기능을 대리하여 다른 클래스가 대신 수행하도록 한다.

**언제 사용하나**
: 하나의 클래스가 다양한 기능을 제공해야 하고, 이를 다른 클래스로 분리하여 간접적으로 처리하고자 할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

## 행위(Behavioral) 디자인 패턴

### 🍛 Chain of Responsibility

**목적**
: 요청을 여러 객체가 처리할 수 있도록 체인으로 연결하고, 처음부터 차례로 조건을 만족하는 객체가 처리한다.

**언제 사용하나**
: 요청을 처리할 수 있는 객체가 여러 개 있고, 우선순위를 정하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🥨 Command

**목적**
: 행동을 객체로 캡슐화하여 요청자(Client)와 실행자(Receiver)의 결합도를 낮춘다.

**언제 사용하나**
: 요청의 기록, Undo 기능, Callback 등이 필요할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍦 Iterator

**목적**
: 내부 구현을 노출하지 않고, 컬렉션 객체의 요소들을 순차적으로 탐색할 수 있도록 한다.

**언제 사용하나**
: 일관된 방식의 탐색이 필요하거나, 다단계 탐색이 필요할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍨 Mediator

**목적**
: 두 객체 간의 복잡한 상호작용을 중재자 객체가 관리함으로써 결합도를 낮춘다.

**언제 사용하나**
: 여러 객체 간 복잡한 통신을 하나의 중재 객체로 단순화하고자 할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍬 Memento

**목적**
: 객체의 상태를 외부에 노출하지 않고 저장하고, 이후 복원할 수 있도록 한다.

**언제 사용하나**
: 특정 시점의 상태를 저장했다가 나중에 복원할 필요가 있을 때 (예: Undo 기능)

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍮 Observer

**목적**
: 객체 간 일대다 관계를 정의하여, 하나의 객체 상태가 변경되면 종속된 객체들이 자동으로 알림을 받도록 한다.

**언제 사용하나**
: 어떤 객체의 상태 변화에 따라 관련된 여러 객체를 동기화하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍩 Visitor

**목적**
: 기존 객체의 구조를 변경하지 않고, 새로운 동작을 추가할 수 있게 한다.

**언제 사용하나**
: 클래스는 변경하지 않고, 외부에서 새로운 기능을 자주 추가해야 할 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍻 Strategy

**목적**
: 알고리즘 군을 정의하고 각각 캡슐화하여 필요에 따라 알고리즘을 교체할 수 있게 한다.

**언제 사용하나**
: 상황에 따라 다른 전략을 선택해야 할 때, 전략 객체를 바꿔 사용하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🍰 State

**목적**
: 객체의 상태에 따라 동작이 달라지도록 하며, 마치 클래스 자체가 바뀌는 것처럼 보이게 한다.

**언제 사용하나**
: 객체가 여러 조건에 따라 다른 행동을 해야 할 때, 조건문 남용을 피하고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

### 🥝 Template

**목적**
: 알고리즘의 구조를 정의하고, 일부 단계를 하위 클래스에서 구현하도록 한다.

**언제 사용하나**
: 전체적인 프로세스는 동일하지만, 일부 동작만 유연하게 바꾸고 싶을 때

💎 [예시 코드](src/Creational/SimpleFactory.dart)

---

## 감사의 말

디자인 패턴을 체계적으로 학습하고자 오래 고민해왔고, 마침내 결심한 뒤 GitHub에서 `windsuzu/Design-Pattern` 프로젝트를 만나 큰 도움을 받았습니다. 원작자분께 깊은 감사를 전합니다.

본 프로젝트의 내용은 `windsuzu/Design-Pattern`를 기반으로 약간의 수정과 개인적인 해석을 추가하여 구성되었습니다.

비록 디자인 패턴을 처음 접하며 작성한 자료지만, 오류나 부족한 부분이 있다면 언제든지 피드백 부탁드립니다.

감사합니다.
